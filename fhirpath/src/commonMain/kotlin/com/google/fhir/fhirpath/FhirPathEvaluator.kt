/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.fhir.fhirpath

import com.google.fhir.fhirpath.functions.invoke
import com.google.fhir.fhirpath.functions.toQuantity
import com.google.fhir.fhirpath.functions.union
import com.google.fhir.fhirpath.operators.addition
import com.google.fhir.fhirpath.operators.and
import com.google.fhir.fhirpath.operators.`as`
import com.google.fhir.fhirpath.operators.compare
import com.google.fhir.fhirpath.operators.concat
import com.google.fhir.fhirpath.operators.div
import com.google.fhir.fhirpath.operators.division
import com.google.fhir.fhirpath.operators.equals
import com.google.fhir.fhirpath.operators.equivalent
import com.google.fhir.fhirpath.operators.implies
import com.google.fhir.fhirpath.operators.`is`
import com.google.fhir.fhirpath.operators.mod
import com.google.fhir.fhirpath.operators.multiplication
import com.google.fhir.fhirpath.operators.or
import com.google.fhir.fhirpath.operators.subtraction
import com.google.fhir.fhirpath.operators.xor
import com.google.fhir.fhirpath.parsers.fhirpathBaseVisitor
import com.google.fhir.fhirpath.parsers.fhirpathParser
import com.google.fhir.fhirpath.types.FhirPathDateTime
import com.google.fhir.fhirpath.types.FhirPathTime
import com.google.fhir.model.r4.FhirDate
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant

/**
 * The core of the FHIRPath engine. This class walks the parse tree generated by ANTLR and evaluates
 * the expression. It uses a visitor pattern, with a method for each type of grammar rule.
 *
 * @param initialContext The starting com.google.fhir.fhirpath.codegen.collection of FHIR resources
 *   for the expression.
 */
internal class FhirPathEvaluator(initialContext: Any?) : fhirpathBaseVisitor<Collection<Any>>() {

  private val contextStack = ArrayDeque<Collection<Any>>()
  private val thisStack = ArrayDeque<Any>()

  // Ensure determinism of current date and time functions by getting the current timestamp once.
  // See https://hl7.org/fhirpath/N1/#current-date-and-time-functions.
  private val now: Instant = Clock.System.now()

  init {
    if (initialContext != null) {
      contextStack.add(listOf(initialContext))
      thisStack.add(initialContext)
    }
  }

  override fun defaultResult(): Collection<Any> = emptyList()

  override fun aggregateResult(
    aggregate: Collection<Any>,
    nextResult: Collection<Any>,
  ): Collection<Any> {
    return aggregate + nextResult
  }

  // expression

  override fun visitInvocationExpression(
    ctx: fhirpathParser.InvocationExpressionContext
  ): Collection<Any> {
    contextStack.addLast(visit(ctx.expression()))
    return visit(ctx.invocation()).also { contextStack.removeLast() }
  }

  override fun visitIndexerExpression(
    ctx: fhirpathParser.IndexerExpressionContext
  ): Collection<Any> {
    val baseCollection = visit(ctx.expression(0)!!)
    val indexer = visit(ctx.expression(1)!!).single() as Int
    return listOf(baseCollection.elementAt(indexer))
  }

  override fun visitPolarityExpression(
    ctx: fhirpathParser.PolarityExpressionContext
  ): Collection<Any> {
    val expression = visit(ctx.expression())
    check(expression.size <= 1) {
      "Polarity expression cannot be applied to a collection with more than 1 item"
    }

    val item = expression.singleOrNull() ?: return emptyList()
    return when (val op = ctx.getChild(0)!!.text) {
      "+" -> listOf(item)
      "-" -> {
        when (item) {
          is Int -> listOf(-item)
          is Long -> listOf(-item)
          is Double -> listOf(-item)
          // TODO: Add support for quantity
          else -> error("Polarity expression cannot be applied to: $item")
        }
      }
      else -> error("Unknown polarity operator: $op")
    }
  }

  override fun visitMultiplicativeExpression(
    ctx: fhirpathParser.MultiplicativeExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    val op = ctx.getChild(1)!!.text
    return when (op) {
      "*" -> multiplication(left, right)
      "/" -> division(left, right)
      "div" -> div(left, right)
      "mod" -> mod(left, right)
      else -> error("Unknown multiplicative operator: $op")
    }
  }

  override fun visitAdditiveExpression(
    ctx: fhirpathParser.AdditiveExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    val op = ctx.getChild(1)!!.text

    return when (op) {
      "+" -> addition(left, right)
      "-" -> subtraction(left, right)
      "&" -> concat(left, right)
      else -> error("Unknown additive operator: $op")
    }
  }

  override fun visitTypeExpression(ctx: fhirpathParser.TypeExpressionContext): Collection<Any> {
    val expression = visit(ctx.expression())
    val typeSpecifier = visit(ctx.typeSpecifier())

    return when (ctx.getChild(1)!!.text) {
      "as" -> expression.`as`(typeSpecifier.toList())
      "is" -> expression.`is`(typeSpecifier.toList())
      else -> error("Unknown type operator: ${ctx.getChild(1)!!.text}")
    }
  }

  override fun visitUnionExpression(ctx: fhirpathParser.UnionExpressionContext): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return left.union(right)
  }

  override fun visitInequalityExpression(
    ctx: fhirpathParser.InequalityExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    check(left.size <= 1 && right.size <= 1) {
      "Inequality expression cannot be applied to a collection with more than 1 item"
    }

    val leftItem = left.singleOrNull() ?: return emptyList()
    val rightItem = right.singleOrNull() ?: return emptyList()
    val comparisonResult = compare(leftItem, rightItem) ?: return emptyList()

    return when (val op = ctx.getChild(1)!!.text) {
      "<" -> listOf(comparisonResult < 0)
      "<=" -> listOf(comparisonResult <= 0)
      ">" -> listOf(comparisonResult > 0)
      ">=" -> listOf(comparisonResult >= 0)
      else -> throw IllegalStateException("Unknown inequality operator: $op")
    }
  }

  override fun visitEqualityExpression(
    ctx: fhirpathParser.EqualityExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)

    if (left.isEmpty() || right.isEmpty()) {
      return emptyList()
    }

    val op = ctx.getChild(1)!!.text
    if (left.size != right.size) {
      return when (op) {
        "=",
        "~" -> listOf(false)
        "!=",
        "!~" -> listOf(true)
        else -> error("Unknown equality operator: $op")
      }
    }

    // The FHIRPath specification states every pair of items must be equal for two collections to be
    // equal. However, it does not explicitly states how to account for item comparison results that
    // are empty sets. This can be interpreted as an inconsistency since this definition does not
    // reduce nicely to the special case of collections with a single item. Consider two collections
    // with a single item in each that are incomparable (returns empty set if compared), if we use
    // the definition of equality for collections, we would conclude the two collections are not
    // equal. But the special case states that an empty set should be returned.
    // This nuance results in inconsistent behaviors in different implementations. See
    // [discussion](https://chat.fhir.org/#narrow/channel/179266-fhirpath/topic/Collection.20equality/with/540473873).
    // In our implementation we choose to treat empty sets as inconclusive, and return an empty set
    // if the equality of two collections cannot be decided.
    // Also see: https://jira.hl7.org/browse/FHIR-53076
    val pairwiseComparisons =
      when {
        op.contains("=") -> left.zip(right).map { (l, r) -> equals(l, r) }
        op.contains("~") -> left.zip(right).map { (l, r) -> equivalent(l, r) }
        else -> error("Unknown equality operator: $op")
      }

    val negated = op.contains("!")
    return when {
      pairwiseComparisons.any { it == false } -> listOf(negated)
      pairwiseComparisons.all { it == true } -> listOf(!negated)
      else -> emptyList()
    }
  }

  override fun visitMembershipExpression(
    ctx: fhirpathParser.MembershipExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    val op = ctx.getChild(1)!!.text
    return when (op) {
      "in" -> listOf(right.contains(left.single()))
      "contains" -> listOf(left.contains(right.single()))
      else -> error("Unknown membership operator: $op")
    }
  }

  override fun visitAndExpression(ctx: fhirpathParser.AndExpressionContext): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return and(left, right)
  }

  override fun visitOrExpression(ctx: fhirpathParser.OrExpressionContext): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return when (ctx.getChild(1)!!.text) {
      "or" -> or(left, right)
      "xor" -> xor(left, right)
      else -> error("Unknown operator in orExpression")
    }
  }

  override fun visitImpliesExpression(
    ctx: fhirpathParser.ImpliesExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return implies(left, right)
  }

  // Term

  override fun visitParenthesizedTerm(
    ctx: fhirpathParser.ParenthesizedTermContext
  ): Collection<Any> {
    // The result is simply the result of the expression inside the parentheses.
    return visit(ctx.expression())
  }

  // literal

  override fun visitBooleanLiteral(ctx: fhirpathParser.BooleanLiteralContext): Collection<Any> {
    return listOf(ctx.text.toBoolean())
  }

  override fun visitStringLiteral(ctx: fhirpathParser.StringLiteralContext): Collection<Any> {
    return listOf(unescapeFhirPathString(ctx.text.drop(1).dropLast(1)))
  }

  override fun visitNumberLiteral(ctx: fhirpathParser.NumberLiteralContext): Collection<Any> {
    val numberText = ctx.text
    return if (numberText.contains('.')) {
      listOf(numberText.toDouble())
    } else {
      listOf(numberText.toInt())
    }
  }

  override fun visitDateLiteral(ctx: fhirpathParser.DateLiteralContext): Collection<Any> {
    val dateString = ctx.text.removePrefix("@")
    return listOf(FhirDate.fromString(dateString)!!)
  }

  override fun visitDateTimeLiteral(ctx: fhirpathParser.DateTimeLiteralContext): Collection<Any> {
    val dateTimeString = ctx.text.removePrefix("@").removeSuffix("T")
    return listOf(FhirPathDateTime.fromString(dateTimeString))
  }

  override fun visitTimeLiteral(ctx: fhirpathParser.TimeLiteralContext): Collection<Any> {
    val timeString = ctx.text.removePrefix("@T")
    return listOf(FhirPathTime.fromString(timeString))
  }

  override fun visitQuantityLiteral(ctx: fhirpathParser.QuantityLiteralContext): Collection<Any> {
    val number = ctx.quantity().NUMBER().text.toDouble()
    val unit =
      ctx.quantity().unit()?.text!! // ?.drop(1)?.dropLast(1)!! // Strip the quotation marks

    return listOf((number to unit).toQuantity())
  }

  // invocation

  override fun visitMemberInvocation(ctx: fhirpathParser.MemberInvocationContext): Collection<Any> {
    val memberName = visit(ctx.identifier()).first() as String

    // Evaluate to the initial context if it matches the resource type
    with(contextStack.first().single()) {
      if (this::class.simpleName == memberName) {
        return listOf(this)
      }
    }

    // Use $this context if the member invocation is implicit, otherwise use the evaluation context
    val context =
      if (ctx.getParent() is fhirpathParser.InvocationExpressionContext) {
        contextStack.last()
      } else {
        listOf(thisStack.last())
      }

    ctx.getParent() ==
      return context.flatMap { item ->
        val fieldValue = item.accessMember(memberName)
        when (fieldValue) {
          null -> emptyList()
          is List<*> -> fieldValue as Collection<Any>
          else -> listOf(fieldValue)
        }
      }
  }

  override fun visitFunctionInvocation(
    ctx: fhirpathParser.FunctionInvocationContext
  ): Collection<Any> {
    val context = contextStack.last()
    val functionNode = ctx.function()
    val functionName = visit(functionNode.identifier()).first() as String

    return when (functionName) {
      "iif" -> {
        // See
        // [specification](https://hl7.org/fhirpath/N1/#iifcriterion-expression-true-result-collection-otherwise-result-collection-collection).
        // N.B. this function is implemented here due to its short-circuiting behavior.
        val params = functionNode.paramList()!!.expression()
        val criterion = visit(params[0])
        check(criterion.size <= 1) { "iif cannot be called on a collection with more than 1 item" }
        return when (criterion.singleOrNull()) {
          true -> visit(params[1])
          false,
          null -> params.getOrNull(2)?.let { visit(it) } ?: emptyList()
          else -> error("iif criterion must evaluate to a Boolean")
        }
      }
      "exists" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#existscriteria-expression-boolean).
        val paramList = functionNode.paramList() ?: return listOf(context.isNotEmpty())
        val expression = paramList.expression().single()
        listOf(
          context.any {
            // Set the single item in the collection as the context for the expression
            thisStack.addLast(it)
            val result = visit(expression)
            thisStack.removeLast()
            result.singleOrNull() == true
          }
        )
      }
      "all" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#allcriteria-expression-boolean).
        val expression = functionNode.paramList()!!.expression().single()
        listOf(
          context.all {
            // Set the single item in the collection as the context for the expression
            thisStack.addLast(it)
            val result = visit(expression)
            thisStack.removeLast()
            result.singleOrNull() == true
          }
        )
      }
      "where" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#wherecriteria-expression-collection).
        val expression = functionNode.paramList()!!.expression().single()
        context.filter {
          // Set the single item in the collection as the context for the expression
          thisStack.addLast(it)
          val result = visit(expression)
          thisStack.removeLast()
          result.singleOrNull() == true
        }
      }
      "select" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#selectprojection-expression-collection).
        val projection = functionNode.paramList()!!.expression().single()
        context.flatMap {
          // Set the single item as the context for the projection
          thisStack.addLast(it)
          val projectionResult = visit(projection)
          thisStack.removeLast()
          projectionResult
        }
      }
      "trace" -> {
        // See
        // [specification](https://hl7.org/fhirpath/N1/#tracename-string-projection-expression-collection).
        val name = visit(functionNode.paramList()!!.expression()[0])
        val projection = functionNode.paramList()!!.expression().getOrNull(1)?.let { visit(it) }
        // TODO: implement this for multiplatform.
        println("$name $projection")
        context
      }
      "is" -> {
        val type = FhirPathType.fromString(functionNode.paramList()!!.expression().single().text)
        return context.`is`(listOf(type))
      }
      "as" -> {
        val type = FhirPathType.fromString(functionNode.paramList()!!.expression().single().text)
        return context.`as`(listOf(type))
      }
      else -> {
        // First-order functions that do not require in-context expression valuation or
        // short-circuiting
        val receiver =
          if (ctx.getParent() is fhirpathParser.InvocationExpressionContext) {
            context
          } else {
            listOf(thisStack.last())
          }
        val params = functionNode.paramList()?.expression()?.flatMap { visit(it) } ?: emptyList()
        receiver.invoke(functionName, params, now)
      }
    }
  }

  override fun visitThisInvocation(ctx: fhirpathParser.ThisInvocationContext): Collection<Any> {
    return listOf(thisStack.last())
  }

  // typeSpecifier

  override fun visitTypeSpecifier(ctx: fhirpathParser.TypeSpecifierContext): Collection<Any> {
    return listOf(FhirPathType.fromString(ctx.text))
  }

  // identifier

  override fun visitIdentifier(ctx: fhirpathParser.IdentifierContext): Collection<Any> {
    val identifierText = ctx.text
    return listOf(identifierText.removeSurrounding("`"))
  }
}

/** See [specification](https://hl7.org/fhirpath/#string). */
private fun unescapeFhirPathString(string: String) =
  if (string.indexOf("\\") == -1) {
    string
  } else {
    StringBuilder()
      .apply {
        var i = 0
        while (i < string.length) {
          val char = string[i]
          if (char != '\\') {
            append(char)
            i++
            continue
          }

          i++
          if (i >= string.length) {
            break
          }
          when (val nextChar = string[i]) {
            '\'',
            '"',
            '`',
            '\\' -> append(nextChar)
            'r' -> append('\r')
            'n' -> append('\n')
            't' -> append('\t')
            'f' -> append('\u000C')
            'u' -> {
              if (i + 4 < string.length) {
                val hex = string.substring(i + 1, i + 5)
                val intValue = hex.toIntOrNull(16)
                if (intValue != null) {
                  append(intValue.toChar())
                  i += 4
                } else {
                  append('u') // Ignore backlash if not followed by a valid hex sequence
                }
              } else {
                append('u') // Ignore backlash if not followed by 4 hex digits
              }
            }
            else -> append(nextChar)
          }
          i++
        }
      }
      .toString()
  }
