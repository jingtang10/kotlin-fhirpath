# Kotlin FHIRPath

[![stability-wip](https://img.shields.io/badge/stability-wip-lightgrey.svg)](https://guidelines.denpa.pro/stability#work-in-progress)
![Static Badge](https://img.shields.io/badge/tests_passing-694%2F930-f4d03f)
[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

Kotlin FHIRPath is an implementation of [HL7® FHIR®](https://www.hl7.org/fhir/overview.html)'s
[FHIRPath](https://hl7.org/fhirpath/N1/) on
[Kotlin Multiplatform](https://kotlinlang.org/docs/multiplatform.html).

**Warning:** The library is WIP. DO NOT USE.

## Key features

* Built with an [ANTLR](https://www.antlr.org/)-generated parser for strict adherence to the formal
  FHIRPath grammar
* Conforms strictly to the specification, with predictable and well-documented behavior
* Support for validation, conversion, and comparison between compatible
  [UCUM](http://unitsofmeasure.org/ucum.html) units
* Designed for portability, providing a single engine across JVM, Android, iOS, Web (JS), and Native
  platforms
* Tested against the official [FHIR test cases](https://github.com/FHIR/fhir-test-cases) to
  guarantee correctness

## FHIRPath version support

The implementation is based on the [FHIRPath Normative Release](https://hl7.org/fhirpath/N1/).
However, we also incorporate some of the latest features and clarifications from the
[Continuous Build](https://build.fhir.org/ig/HL7/FHIRPath/) wherever feasible. Please note the
experimental nature of the sections marked as STU (Standard for Trial Use) in the Continuous Build.

## Implementation

This project uses [ANTLR Kotlin](https://github.com/Strumenta/antlr-kotlin) to generate the
lexer, parser and visitor directly from the formal FHIRPath grammar. This automated approach ensures
correctness, improves maintainability, and significantly reduces development time.

The
[FHIRPath Evaluator](fhirpath/src/commonMain/kotlin/com/google/fhir/fhirpath/FhirPathEvaluator.kt)
implements the visitor class generated by ANTLR, evaluating FHIRPath expressions by traversing the
in-memory data model from the [Kotlin FHIR](https://github.com/google/kotlin-fhir) library.

A key requirement for FHIRPath evaluation is the capability to access data elements by name. To
achieve this with cross-platform compatibility (avoiding reflection), a codegen embedded in
`buildSrc` generates helper functions to the Kotlin FHIR data model.

```mermaid
graph LR
    A(formal FHIRPath grammar) -- ANTLR Kotlin --> B(lexer, parser, visitor)
    C(Kotlin FHIR data model<br>com.google.fhir:fhir-model)
    subgraph buildSrc
        direction LRTB
        D(FHIR spec<br>in JSON) -- kotlinx.serialization --> E(instances of<br>StructureDefinition<br>Kotlin data class<br>)
        E -- KotlinPoet --> F[generated helper functions]
    end
    B --> G(FHIRPath Evaluator)
    C --> G
    F --> G
```

*Figure 1: Architecture diagram*

The following table lists the chosen internal types for the FHIRPath primitive types.

| FHIRPath type <img src="images/fhir.png" alt="kotlin" style="height: 1em"/> | Internal type <img src="images/kotlin.png" alt="kotlin" style="height: 1em"/> |
|-----------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| Boolean                                                                     | kotlin.Boolean                                                                |
| String                                                                      | kotlin.String                                                                 |
| Integer                                                                     | kotlin.Int                                                                    |
| Long                                                                        | kotlin.Long                                                                   |
| Decimal                                                                     | kotlin.Double                                                                 |
| Date                                                                        | FhirDate(*)                                                                   |
| DateTime                                                                    | FhirPathDateTime(**)                                                          |
| Time                                                                        | FhirPathTime(**)                                                              |
| Quantity                                                                    | Quantity(*)                                                                   |

(*): Classes defined in [Kotlin FHIR](https://github.com/google/kotlin-fhir)
(**): Classes defined in this project

Classes from the [Kotlin FHIR](https://github.com/google/kotlin-fhir) are used for more complex
types that do not have direct representations in Kotlin. For DateTime and Time, the requirements in
FHIRPath are more lenient than in the FHIR specification. As a result, custom classes need to be
authored to handle cases where the minutes, seconds, or milliseconds are not present (allowed in
FHIRPath but not allowed in FHIR).

### Calendar durations in FHIRPath vs. definite durations in UCUM

FHIRPath defines calendar durations (`year`, `month`, `week`, `day`, `hour`, `minute`, `second`,
`millisecond` and their plural forms) that can be
[mapped]((https://hl7.org/fhirpath/N1/#time-valued-quantities)) to definite durations (`'a'`,
`'mo'`, `'wk'`, `'d'`, `'h'`, `'min'`, `'s'`, `'ms'`) in
[UCUM](http://unitsofmeasure.org/ucum.html). However, the conversion between calendar durations
in FHIRPath is [defined](https://hl7.org/fhirpath/N1/#toquantityunit-string-quantity) differently
from the UCUM specification for year and month. For example, `1 year` in FHIRPath can be converted
to `365 days` but `1 'a'` in UCUM is `365.25 'd'`.

This is understandable, since the calendar durations in FHIRPath represent conventional durations
for reasoning about dates and times, whereas the definite durations in UCUM represent precise
scientific units. However, the equivalence relationship between them is
[defined](https://hl7.org/fhirpath/N1/#quantity-equality) using the 1:1 mapping, this creates a
paradox, which is illustrated in the following diagram:

```mermaid
block
    columns 8
    space A["year"] space:4 B["day"] space
    space:8
    space C["'a'"] space:4 D["'d'"] space

    A -- "1 year ~ 365 days" --- B
    C -- "1 'a' ~ 365.25 'd'" --- D
    A -- "1 year ~ 1 'a'" ---C
    B -- "1 day ~ 1 'd'" ---D
```

*Figure 2: Paradox of calendar durations in FHIRPath vs. definite durations in UCUM*

Is `1 year` equivalent to `365 'd'` or `365.25 'd'`? The answer is both, depending on the order of
conversion. But logically this results in a paradox `365 = 365.25`, which is an undesirable
artifact. As such, not all edges in the diagram can be honored in a logically consistent way.

Happily, this is only a problem for the units that have different conversion factors as calendar
durations and definite units, i.e., year and month. All other units (week, day, hour, minute,
second, millisecond) are aligned in FHIRPath and UCUM. To prioritize predictability and consistency,
our implementation makes a deliberate choice: **drop the equivalence relationship between the
calendar duration and the definite unit for year and month**:

```
1 year !~ 1 'a'
1 month !~ 1 'mo'
```

By doing so, we effectively drop the left edge in Figure 2, and choose `1 year` to be `365 days` and
`1 month` to be `30 days`. This is the smallest modification we can make whilst maintaining the
consistent conversion of units under equivalence.

> **Note:** The equality relationship between calendar durations and definite units is unaffected by
> this change.

#### 

## User Guide

## Developer Guide

### ANTLR

To generate the lexer, parser, and visitor locally using ANTLR Kotlin:

```shell
./gradlew generateKotlinGrammarSource
```

The generated code will be placed in `fhirpath/build/generatedAntlr`.

### Model extensions

To run the codegen in `buildSrc` locally:

```shell
./gradlew generateR4Helpers
```

The generated code will be located in `fhirpath/build/generated`.

### Dependencies

Dependencies must be kept in sync between the
[`buildSrc/build.gradle.kts`](buildSrc/build.gradle.kts) file and the
[`gradle/libs.versions.toml`](gradle/libs.versions.toml) file. The former cannot use the latter
since the `buildSrc` directory is precompiled separately in Gradle.

### Tests

[XmlUtil](https://github.com/pdvrieze/xmlutil) is used to load the XML test cases from the
`third_party` directory. To run the tests:

```shell
./gradlew :fhirpath:jvmTest
```

The number of passing test cases is displayed on a badge at the top of this page.

### Third Party

The [third_party](third_party/) directory includes resources from the FHIRPath specification and related
repositories for code generation and testing purposes:
- [`fhir-test-cases`](third_party/fhir-test-cases/): content from the
[fhir-test-cases](https://github.com/FHIR/fhir-test-cases) repo
- [`tests-fhir-r4.xml`](third_party/fhir-test-cases/r4/tests-fhir-r4.xml): R4 test cases
([commit](https://github.com/FHIR/fhir-test-cases/blob/dc86fa6f5225ac27b42046bb3ba2254ff688d3df/r4/fhirpath/tests-fhir-r4.xml))
- [`resources`](third_party/fhir-test-cases/r4/resources) JSON versions of the relevant test
resources generated using [Anton V.](https://www.antvaset.com/)'s
[FHIR Converter](https://www.antvaset.com/fhir-converter) alongside the XML versions
([commit](https://github.com/FHIR/fhir-test-cases/tree/dc86fa6f5225ac27b42046bb3ba2254ff688d3df/r4))
- [`fhirpath-2.0.0`](third_party/fhirpath-2.0.0/): the formal
[antlr grammar](https://hl7.org/fhirpath/N1/grammar.html) from the FHIRPath Normative Release
[N1 (v2.0.0)](https://hl7.org/fhirpath/N1/) including
- [`hl7.fhir.r4.core`](third_party/hl7.fhir.r4.core/): content from
[FHIR R4](https://hl7.org/fhir/R4/) for code generation
- [UCUM](third_party/ucum/): content from the [UCUM](https://github.com/ucum-org/ucum) repo

## Disclaimer

This is not an officially supported Google product. This project is not
eligible for the [Google Open Source Software Vulnerability Rewards
Program](https://bughunters.google.com/open-source-security).
