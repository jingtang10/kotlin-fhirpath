/*
 * Copyright 2025-2026 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.fhir.fhirpath

import com.google.fhir.fhirpath.functions.invoke
import com.google.fhir.fhirpath.functions.union
import com.google.fhir.fhirpath.model.FhirModelNavigator
import com.google.fhir.fhirpath.operators.addition
import com.google.fhir.fhirpath.operators.and
import com.google.fhir.fhirpath.operators.`as`
import com.google.fhir.fhirpath.operators.compare
import com.google.fhir.fhirpath.operators.concat
import com.google.fhir.fhirpath.operators.div
import com.google.fhir.fhirpath.operators.division
import com.google.fhir.fhirpath.operators.equal
import com.google.fhir.fhirpath.operators.equivalent
import com.google.fhir.fhirpath.operators.implies
import com.google.fhir.fhirpath.operators.`is`
import com.google.fhir.fhirpath.operators.mod
import com.google.fhir.fhirpath.operators.multiplication
import com.google.fhir.fhirpath.operators.or
import com.google.fhir.fhirpath.operators.subtraction
import com.google.fhir.fhirpath.operators.xor
import com.google.fhir.fhirpath.parsers.fhirpathBaseVisitor
import com.google.fhir.fhirpath.parsers.fhirpathParser
import com.google.fhir.fhirpath.types.FhirPathDate
import com.google.fhir.fhirpath.types.FhirPathDateTime
import com.google.fhir.fhirpath.types.FhirPathQuantity
import com.google.fhir.fhirpath.types.FhirPathTime
import com.google.fhir.fhirpath.types.FhirPathTypeResolver
import com.ionspin.kotlin.bignum.decimal.BigDecimal
import com.ionspin.kotlin.bignum.decimal.toBigDecimal
import kotlin.time.Clock
import kotlin.time.ExperimentalTime
import kotlin.time.Instant

/**
 * The core of the FHIRPath engine. This class walks the parse tree generated by ANTLR and evaluates
 * the expression. It uses a visitor pattern, with a method for each type of grammar rule.
 *
 * N.B. Each group of "visit*" functions in this class implements a single grammar rule in the
 * `fhirpath.g4` file with a preceding line comment noting the name of the rule. The order of the
 * "visit*" functions should be kept in sync with the order of the rules in the `fhirpath.g4` file.
 *
 * @param initialContext The starting com.google.fhir.fhirpath.codegen.collection of FHIR resources
 *   for the expression.
 */
internal class FhirPathEvaluator(
  val fhirPathTypeResolver: FhirPathTypeResolver,
  val fhirModelNavigator: FhirModelNavigator,
) : fhirpathBaseVisitor<Collection<Any>>() {
  private var resource: Any? = null
  private val contextStack = ArrayDeque<Collection<Any>>()
  private val thisStack = ArrayDeque<Any>()
  private val totalStack = ArrayDeque<Collection<Any>>()
  private val variables = mutableMapOf<String, Any?>()
  @OptIn(ExperimentalTime::class) private var now: Instant = Clock.System.now()

  @OptIn(ExperimentalTime::class)
  fun initialize(context: Any?, variables: Map<String, Any?>? = emptyMap()) {
    resource = null
    contextStack.clear()
    thisStack.clear()
    totalStack.clear()
    this.variables.clear()

    if (context != null) {
      resource = context
      contextStack.add(listOf(context))
      thisStack.add(context)
    }

    if (variables != null) {
      this.variables.putAll(variables)
    }

    // Ensure determinism of current date and time functions by getting the current timestamp once.
    // See https://hl7.org/fhirpath/N1/#current-date-and-time-functions.
    now = Clock.System.now()
  }

  override fun defaultResult(): Collection<Any> = emptyList()

  override fun aggregateResult(
    aggregate: Collection<Any>,
    nextResult: Collection<Any>,
  ): Collection<Any> {
    return aggregate + nextResult
  }

  // expression

  override fun visitInvocationExpression(
    ctx: fhirpathParser.InvocationExpressionContext
  ): Collection<Any> {
    contextStack.addLast(visit(ctx.expression()))
    return visit(ctx.invocation()).also { contextStack.removeLast() }
  }

  override fun visitIndexerExpression(
    ctx: fhirpathParser.IndexerExpressionContext
  ): Collection<Any> {
    val baseCollection = visit(ctx.expression(0)!!)
    val indexer = visit(ctx.expression(1)!!).single() as Int
    return listOf(baseCollection.elementAt(indexer))
  }

  override fun visitPolarityExpression(
    ctx: fhirpathParser.PolarityExpressionContext
  ): Collection<Any> {
    val expression = visit(ctx.expression())
    check(expression.size <= 1) {
      "Polarity expression cannot be applied to a collection with more than 1 item"
    }

    val item = expression.singleOrNull() ?: return emptyList()
    return when (val op = ctx.getChild(0)!!.text) {
      "+" -> listOf(item)
      "-" -> {
        when (item) {
          is Int -> listOf(-item)
          is Long -> listOf(-item)
          is BigDecimal -> listOf(-item)
          is FhirPathQuantity -> listOf(item.negate())
          else -> error("Polarity expression cannot be applied to: $item")
        }
      }
      else -> error("Unknown polarity operator: $op")
    }
  }

  override fun visitMultiplicativeExpression(
    ctx: fhirpathParser.MultiplicativeExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    val op = ctx.getChild(1)!!.text
    return when (op) {
      "*" -> multiplication(left, right, fhirPathTypeResolver)
      "/" -> division(left, right, fhirPathTypeResolver)
      "div" -> div(left, right)
      "mod" -> mod(left, right)
      else -> error("Unknown multiplicative operator: $op")
    }
  }

  override fun visitAdditiveExpression(
    ctx: fhirpathParser.AdditiveExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    val op = ctx.getChild(1)!!.text

    return when (op) {
      "+" -> addition(left, right, fhirPathTypeResolver)
      "-" -> subtraction(left, right, fhirPathTypeResolver)
      "&" -> concat(left, right)
      else -> error("Unknown additive operator: $op")
    }
  }

  override fun visitTypeExpression(ctx: fhirpathParser.TypeExpressionContext): Collection<Any> {
    val expression = visit(ctx.expression())
    val typeSpecifier = visit(ctx.typeSpecifier())

    return when (ctx.getChild(1)!!.text) {
      "as" -> expression.`as`(typeSpecifier.toList(), fhirPathTypeResolver)
      "is" -> expression.`is`(typeSpecifier.toList(), fhirPathTypeResolver)
      else -> error("Unknown type operator: ${ctx.getChild(1)!!.text}")
    }
  }

  override fun visitUnionExpression(ctx: fhirpathParser.UnionExpressionContext): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return left.union(right)
  }

  override fun visitInequalityExpression(
    ctx: fhirpathParser.InequalityExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    check(left.size <= 1 && right.size <= 1) {
      "Inequality expression cannot be applied to a collection with more than 1 item"
    }

    val leftItem = left.singleOrNull() ?: return emptyList()
    val rightItem = right.singleOrNull() ?: return emptyList()
    val comparisonResult = compare(leftItem, rightItem, fhirPathTypeResolver) ?: return emptyList()

    return when (val op = ctx.getChild(1)!!.text) {
      "<" -> listOf(comparisonResult < 0)
      "<=" -> listOf(comparisonResult <= 0)
      ">" -> listOf(comparisonResult > 0)
      ">=" -> listOf(comparisonResult >= 0)
      else -> throw IllegalStateException("Unknown inequality operator: $op")
    }
  }

  override fun visitEqualityExpression(
    ctx: fhirpathParser.EqualityExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)

    val op = ctx.getChild(1)!!.text
    val negated = op.contains("!")
    val result =
      when {
        op.contains("=") -> equal(left, right, fhirPathTypeResolver)
        op.contains("~") -> equivalent(left, right, fhirPathTypeResolver)
        else -> error("Unknown equality operator: $op")
      }
    return when (result) {
      true -> listOf(!negated)
      false -> listOf(negated)
      null -> emptyList()
    }
  }

  override fun visitMembershipExpression(
    ctx: fhirpathParser.MembershipExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    val op = ctx.getChild(1)!!.text
    return when (op) {
      "in" ->
        listOf(
          right
            .map { it.toFhirPathType(fhirPathTypeResolver) }
            .contains(left.single().toFhirPathType(fhirPathTypeResolver))
        )
      "contains" ->
        listOf(
          left
            .map { it.toFhirPathType(fhirPathTypeResolver) }
            .contains(right.single().toFhirPathType(fhirPathTypeResolver))
        )
      else -> error("Unknown membership operator: $op")
    }
  }

  override fun visitAndExpression(ctx: fhirpathParser.AndExpressionContext): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return and(left, right)
  }

  override fun visitOrExpression(ctx: fhirpathParser.OrExpressionContext): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return when (ctx.getChild(1)!!.text) {
      "or" -> or(left, right)
      "xor" -> xor(left, right)
      else -> error("Unknown operator in orExpression")
    }
  }

  override fun visitImpliesExpression(
    ctx: fhirpathParser.ImpliesExpressionContext
  ): Collection<Any> {
    val left = visit(ctx.expression(0)!!)
    val right = visit(ctx.expression(1)!!)
    return implies(left, right)
  }

  // Term

  override fun visitParenthesizedTerm(
    ctx: fhirpathParser.ParenthesizedTermContext
  ): Collection<Any> {
    // The result is simply the result of the expression inside the parentheses.
    return visit(ctx.expression())
  }

  // literal

  override fun visitBooleanLiteral(ctx: fhirpathParser.BooleanLiteralContext): Collection<Any> {
    return listOf(ctx.text.toBoolean())
  }

  override fun visitStringLiteral(ctx: fhirpathParser.StringLiteralContext): Collection<Any> {
    return listOf(unescapeFhirPathString(ctx.text.drop(1).dropLast(1)))
  }

  override fun visitNumberLiteral(ctx: fhirpathParser.NumberLiteralContext): Collection<Any> {
    val numberText = ctx.text
    return if (numberText.contains('.')) {
      listOf(numberText.toBigDecimal())
    } else {
      listOf(numberText.toInt())
    }
  }

  override fun visitDateLiteral(ctx: fhirpathParser.DateLiteralContext): Collection<Any> {
    val dateString = ctx.text.removePrefix("@")
    return listOf(FhirPathDate.fromString(dateString))
  }

  override fun visitDateTimeLiteral(ctx: fhirpathParser.DateTimeLiteralContext): Collection<Any> {
    val dateTimeString = ctx.text.removePrefix("@").removeSuffix("T")
    return listOf(FhirPathDateTime.fromString(dateTimeString))
  }

  override fun visitTimeLiteral(ctx: fhirpathParser.TimeLiteralContext): Collection<Any> {
    val timeString = ctx.text.removePrefix("@T")
    return listOf(FhirPathTime.fromString(timeString))
  }

  override fun visitQuantityLiteral(ctx: fhirpathParser.QuantityLiteralContext): Collection<Any> {
    val number = ctx.quantity().NUMBER().text.toBigDecimal()
    val unit = ctx.quantity().unit()?.text!!
    val pair = (number to unit)
    return listOf(FhirPathQuantity(value = pair.first, unit = pair.second))
  }

  // externalConstant

  override fun visitExternalConstantTerm(
    ctx: fhirpathParser.ExternalConstantTermContext
  ): Collection<Any> {
    val constantCtx = ctx.externalConstant()
    val name =
      constantCtx.identifier()?.let { visit(it).single() as String }
        ?: constantCtx.STRING()?.text?.drop(1)?.dropLast(1)
        ?: error("Invalid external constant")

    return when {
      name == "resource" -> resource?.let { listOf(it) } ?: emptyList()
      name == "sct" -> listOf("http://snomed.info/sct")
      name == "loinc" -> listOf("http://loinc.org")
      name == "ucum" -> listOf("http://unitsofmeasure.org")
      name.startsWith("vs-") -> {
        val valueSetId = name.removePrefix("vs-")
        listOf("http://hl7.org/fhir/ValueSet/$valueSetId")
      }
      name.startsWith("ext-") -> {
        val extensionId = name.removePrefix("ext-")
        listOf("http://hl7.org/fhir/StructureDefinition/$extensionId")
      }
      variables.containsKey(name) -> {
        variables[name]?.let { listOf(it) } ?: emptyList()
      }
      else -> error("Unknown variable: %$name")
    }
  }

  // invocation

  override fun visitMemberInvocation(ctx: fhirpathParser.MemberInvocationContext): Collection<Any> {
    val memberName = visit(ctx.identifier()).first() as String

    // Evaluate to the initial context if it matches the resource type
    with(contextStack.first().single()) {
      if (this::class.simpleName == memberName) {
        return listOf(this)
      }
    }

    // Use $this context if the member invocation is implicit, otherwise use the evaluation context
    val context =
      if (ctx.getParent() is fhirpathParser.InvocationExpressionContext) {
        contextStack.last()
      } else {
        listOf(thisStack.last())
      }

    ctx.getParent() ==
      return context.flatMap { item ->
        val fieldValue = fhirModelNavigator.accessProperty(item, memberName)
        when (fieldValue) {
          null -> emptyList()
          is List<*> -> fieldValue as Collection<Any>
          else -> listOf(fieldValue)
        }
      }
  }

  @OptIn(ExperimentalTime::class)
  override fun visitFunctionInvocation(
    ctx: fhirpathParser.FunctionInvocationContext
  ): Collection<Any> {
    val context = contextStack.last()
    val functionNode = ctx.function()
    val functionName = visit(functionNode.identifier()).first() as String

    return when (functionName) {
      "iif" -> {
        // See
        // [specification](https://hl7.org/fhirpath/N1/#iifcriterion-expression-true-result-collection-otherwise-result-collection-collection).
        // N.B. this function is implemented here due to its short-circuiting behavior.
        check(context.size <= 1) { "iif cannot be called on a collection with more than 1 item" }
        val params = functionNode.paramList()!!.expression()
        val criterion = visit(params[0])
        check(criterion.size <= 1) { "iif cannot be called with multiple expressions" }
        return when (criterion.singleOrNull()) {
          true -> visit(params[1])
          false,
          null -> params.getOrNull(2)?.let { visit(it) } ?: emptyList()
          else -> error("iif criterion must evaluate to a Boolean")
        }
      }
      "exists" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#existscriteria-expression-boolean).
        val paramList = functionNode.paramList() ?: return listOf(context.isNotEmpty())
        val expression = paramList.expression().single()
        listOf(
          context.any {
            // Set the single item in the collection as the context for the expression
            thisStack.addLast(it)
            val result = visit(expression)
            thisStack.removeLast()
            result.singleOrNull() == true
          }
        )
      }
      "all" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#allcriteria-expression-boolean).
        val expression = functionNode.paramList()!!.expression().single()
        listOf(
          context.all {
            // Set the single item in the collection as the context for the expression
            thisStack.addLast(it)
            val result = visit(expression)
            thisStack.removeLast()
            result.singleOrNull() == true
          }
        )
      }
      "where" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#wherecriteria-expression-collection).
        val expression = functionNode.paramList()!!.expression().single()
        context.filter {
          // Set the single item in the collection as the context for the expression
          thisStack.addLast(it)
          val result = visit(expression)
          thisStack.removeLast()
          result.singleOrNull() == true
        }
      }
      "select" -> {
        // See [specification](https://hl7.org/fhirpath/N1/#selectprojection-expression-collection).
        val projection = functionNode.paramList()!!.expression().single()
        context.flatMap {
          // Set the single item as the context for the projection
          thisStack.addLast(it)
          val projectionResult = visit(projection)
          thisStack.removeLast()
          projectionResult
        }
      }
      "aggregate" -> {
        // See
        // [specification](https://hl7.org/fhirpath/N1/#aggregateaggregator-expression-init-value-value).
        val params = functionNode.paramList()!!.expression()
        val aggregator = params[0]
        var total: Collection<Any> = if (params.size > 1) visit(params[1]) else emptyList()

        for (item in context) {
          contextStack.addLast(listOf(item))
          thisStack.addLast(item)
          totalStack.addLast(total)
          total = visit(aggregator)
          totalStack.removeLast()
          thisStack.removeLast()
          contextStack.removeLast()
        }
        total
      }
      "trace" -> {
        // See
        // [specification](https://hl7.org/fhirpath/N1/#tracename-string-projection-expression-collection).
        val name = visit(functionNode.paramList()!!.expression()[0])
        val projection = functionNode.paramList()!!.expression().getOrNull(1)?.let { visit(it) }
        // TODO: implement this for multiplatform.
        println("$name $projection")
        context
      }
      "is" -> {
        val type =
          fhirPathTypeResolver.resolveFromString(
            functionNode.paramList()!!.expression().single().text
          )
        return context.`is`(listOf(type), fhirPathTypeResolver)
      }
      "as" -> {
        val type =
          fhirPathTypeResolver.resolveFromString(
            functionNode.paramList()!!.expression().single().text
          )
        return context.`as`(listOf(type), fhirPathTypeResolver)
      }
      else -> {
        // First-order functions that do not require in-context expression valuation or
        // short-circuiting
        val receiver =
          if (ctx.getParent() is fhirpathParser.InvocationExpressionContext) {
            context
          } else {
            listOf(thisStack.last())
          }
        val params = functionNode.paramList()?.expression()?.flatMap { visit(it) } ?: emptyList()
        receiver.invoke(functionName, params, now, fhirPathTypeResolver, fhirModelNavigator)
      }
    }
  }

  override fun visitThisInvocation(ctx: fhirpathParser.ThisInvocationContext): Collection<Any> {
    return listOf(thisStack.last())
  }

  override fun visitTotalInvocation(ctx: fhirpathParser.TotalInvocationContext): Collection<Any> {
    return totalStack.last()
  }

  // typeSpecifier

  override fun visitTypeSpecifier(ctx: fhirpathParser.TypeSpecifierContext): Collection<Any> {
    return listOf(fhirPathTypeResolver.resolveFromString(ctx.text))
  }

  // identifier

  override fun visitIdentifier(ctx: fhirpathParser.IdentifierContext): Collection<Any> {
    val identifierText = ctx.text
    return listOf(identifierText.removeSurrounding("`"))
  }
}

/** Returns a new [FhirPathQuantity] object with the numeric value negated. */
private fun FhirPathQuantity.negate(): FhirPathQuantity =
  FhirPathQuantity(value = value?.negate(), unit = unit)

/** See [specification](https://hl7.org/fhirpath/#string). */
private fun unescapeFhirPathString(string: String) =
  if (string.indexOf("\\") == -1) {
    string
  } else {
    StringBuilder()
      .apply {
        var i = 0
        while (i < string.length) {
          val char = string[i]
          if (char != '\\') {
            append(char)
            i++
            continue
          }

          i++
          if (i >= string.length) {
            break
          }
          when (val nextChar = string[i]) {
            '\'',
            '"',
            '`',
            '\\' -> append(nextChar)
            'r' -> append('\r')
            'n' -> append('\n')
            't' -> append('\t')
            'f' -> append('\u000C')
            'u' -> {
              if (i + 4 < string.length) {
                val hex = string.substring(i + 1, i + 5)
                val intValue = hex.toIntOrNull(16)
                if (intValue != null) {
                  append(intValue.toChar())
                  i += 4
                } else {
                  append('u') // Ignore backlash if not followed by a valid hex sequence
                }
              } else {
                append('u') // Ignore backlash if not followed by 4 hex digits
              }
            }
            else -> append(nextChar)
          }
          i++
        }
      }
      .toString()
  }
